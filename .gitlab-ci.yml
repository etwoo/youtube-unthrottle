image: debian:unstable-slim

variables:
  DEBIAN_FRONTEND: noninteractive
  TESTS_FAIL_LACK_OF_LANDLOCK_API_IN_CI_RUNNERS: "^(cli-try-sandbox|landlock|sandbox|seccomp)$"

build:gcc:
  stage: build
  before_script:
    - ./scripts/setup/apt.sh
  script:
    - cmake --preset default -DCMAKE_COMPILE_WARNING_AS_ERROR=ON
    - cmake --build --preset default
    - ctest --preset default -E ${TESTS_FAIL_LACK_OF_LANDLOCK_API_IN_CI_RUNNERS}
  artifacts:
    when: always
    reports:
      junit: ./build/junit.xml

build:clang:
  stage: build
  before_script:
    - ./scripts/setup/apt.sh
  script:
    - cmake --preset clang -DCMAKE_COMPILE_WARNING_AS_ERROR=ON
    - cmake --build --preset default
    - ctest --preset default -E ${TESTS_FAIL_LACK_OF_LANDLOCK_API_IN_CI_RUNNERS}
  artifacts:
    when: always
    reports:
      junit: ./build/junit.xml

build:clang-format:
  stage: build
  before_script:
    - ./scripts/setup/apt.sh
  script:
    - cmake --preset default
    - cmake --build --preset default --target fmt

build:clang-coverage:
  stage: build
  # Use medium machine type (instead of default small) to improve VM performance
  tags:
    - saas-linux-medium-amd64
  before_script:
    - apt update -qq && apt install -qqy curl expect jq llvm qemu-system-x86 qemu-utils zstd
    - which llvm-profdata
    - ./scripts/setup/apt.sh
  #
  # For CI_PERSONAL_ACCESS_TOKEN, see: Settings > CI/CD > Variables
  #
  # Increment the BUMP envvar to force a VM image cache miss
  #
  script:
    - cmake --preset coverage
    - cmake --build --preset default
    - export CI_PERSONAL_ACCESS_TOKEN=${CI_PERSONAL_ACCESS_TOKEN}
    - export CI_PROJECT_ID=${CI_PROJECT_ID}
    - export BUMP=12
    - export IMG=$(echo "$BUMP" | sha256sum | cut -f1 -d' ')
    - export URI=$(./scripts/gitlab/find-vm-artifact.sh "vm-images/$IMG.zst") && echo "Fetching $URI"
    - ./scripts/gitlab/qemu-build.exp $IMG $URI
    - ./scripts/coverage.sh -E main.c coverage.profraw ./build/coverage.xml
  after_script:
    - ./scripts/gitlab/cleanup-vm-archive.sh vm-images
  coverage: '/^TOTAL.*\s+([\d\.]+\%)$/'
  artifacts:
    when: always
    paths:
      - vm-images/*.zst
    reports:
      junit: ./build/junit.xml
      coverage_report:
        coverage_format: cobertura
        path: ./build/coverage.xml

#
# Based on https://gitlab.com/gitlab-ci-utils/container-images/vale
#
# Restricting comments in code and internal documentation with Vale would
# probably never make sense in a real software project, especially one with
# a large team of varying language backgrounds.
#
# That said, a pedantic approach does no harm for a personal project
# because at worst, I only shoot myself in the foot.
#
lint:prose:
  stage: build
  image:
    name: registry.gitlab.com/gitlab-ci-utils/container-images/vale:latest
    entrypoint: ['']
  before_script:
    - /vale/sync.sh
  script:
    - ./scripts/check-prose.sh /vale/vale-glcq.tmpl > vale.json
  after_script:
    - jq -r '.[].check_name' vale.json | sort | uniq -c | sort -nr
  artifacts:
    when: always
    reports:
      codequality: vale.json

lint:shell:
  stage: build
  before_script:
    - apt update -qq && apt install -qqy git shellcheck
  script:
    - git ls-files -z '**.sh' | xargs -0 shellcheck --shell=bash

lint:tcl:
  stage: build
  before_script:
    - apt update -qq && apt install -qqy git python3-pip
    - pip install --break-system-packages --root-user-action ignore tclint
  script:
    - git ls-files -z '*.exp' | xargs -0 tclfmt --in-place --indent=tab --
    - git diff --exit-code '*.exp'
    - git ls-files -z '*.exp' | xargs -0 tclint --

#
# Run the Clang Static Analyzer via clang-tidy: https://clang-analyzer.llvm.org
#
analyze:clang-tidy:
  stage: build
  before_script:
    - ./scripts/setup/apt.sh
  script:
    - cmake --preset clang -DCMAKE_C_CLANG_TIDY=clang-tidy
    - cmake --build --preset default
